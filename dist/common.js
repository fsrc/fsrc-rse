// Generated by LiveScript 1.6.0
(function(){
  var ref$, any, filter, each, tail, initial, map, lines, groupBy, keys, maximumBy, drop, spawn2, exec, inspect, fsrcConfig, config, MOSH, SSH, SM, SMLIST, SHELL, SC, TERMINAL, TERMTITLE, TERMEXEC, TERMARGS, spawn, dmenuCmd, createCmd, openCmd, listCmd, windowNameToId, dmenu, focused, windows, sessions, nextIndex, createNew, open, out$ = typeof exports != 'undefined' && exports || this;
  ref$ = require('prelude-ls'), any = ref$.any, filter = ref$.filter, each = ref$.each, tail = ref$.tail, initial = ref$.initial, map = ref$.map, lines = ref$.lines, groupBy = ref$.groupBy, keys = ref$.keys, maximumBy = ref$.maximumBy, drop = ref$.drop;
  ref$ = require('child_process'), spawn2 = ref$.spawn, exec = ref$.exec;
  inspect = require('util').inspect;
  fsrcConfig = require('fsrc-config');
  config = fsrcConfig('rse', {
    "ssh": {
      "cmd": "ssh"
    },
    "mosh": {
      "cmd": "mosh"
    },
    "sessionManager": {
      "cmd": "abduco",
      "listArg": "-l",
      "createArgs": ['zsh']
    },
    "shell": "zsh",
    "separator": "#",
    "terminal": {
      "cmd": "terminator",
      "titleArg": "-T",
      "executeArg": "-e",
      "args": []
    },
    "debug": true
  });
  MOSH = config.mosh.cmd;
  SSH = config.ssh.cmd;
  SM = config.sessionManager.cmd;
  SMLIST = config.sessionManager.listArg;
  SHELL = config.shell;
  SC = config.separator;
  TERMINAL = config.terminal.cmd;
  TERMTITLE = config.terminal.titleArg;
  TERMEXEC = config.terminal.executeArg;
  TERMARGS = config.terminal.args;
  spawn = function(term, args){
    var options, proc;
    options = config.debug
      ? {
        detached: false,
        stdio: 'inherit'
      }
      : {
        detached: true,
        stdio: 'ignore'
      };
    if (config.debug) {
      console.error.apply(this, arguments);
    }
    proc = spawn2(term, args, options);
    if (!config.debug) {
      proc.unref();
    } else {
      proc.on('close', function(code, signal){
        console.error('CLOSED');
        console.error('CODE:', code);
        return console.error('SIGNAL:', signal);
      });
      proc.on('error', function(err){
        console.error('SUB PROCESS ERROR:');
        return console.error(err);
      });
      proc.on('exit', function(code, signal){
        console.error('EXIT');
        console.error('CODE:', code);
        return console.error('SIGNAL:', signal);
      });
    }
    return proc;
  };
  out$.dmenuCmd = dmenuCmd = function(prompt){
    return ['-p', "'" + prompt + "'"];
  };
  out$.createCmd = createCmd = function(termArgs, client, host, session, index){
    var name, title;
    name = session + "" + SC + index;
    title = host + "" + SC + name;
    return {
      mosh: termArgs.concat([TERMTITLE, title, TERMEXEC, MOSH + " " + host + " -- " + SM + " -c " + name + " " + SHELL]),
      ssh: termArgs.concat([TERMTITLE, title, TERMEXEC, SSH + " " + host + " -t -- " + SM + " -c " + name + " " + SHELL])
    }[client];
  };
  out$.openCmd = openCmd = function(termArgs, client, host, session, index){
    var name, title;
    name = session + "" + SC + index;
    title = host + "" + SC + name;
    return {
      mosh: termArgs.concat([TERMTITLE, title, TERMEXEC, MOSH + " " + host + " -- " + SM + " -a " + name]),
      ssh: termArgs.concat([TERMTITLE, title, TERMEXEC, SSH + " " + host + " -t -- " + SM + " -a " + name])
    }[client];
  };
  out$.listCmd = listCmd = function(host){
    return SSH + " " + host + " '" + SM + " " + SMLIST + "'";
  };
  out$.windowNameToId = windowNameToId = function(name){
    var ref$, host, session, index;
    ref$ = name.replace('\n', '').split(SC), host = ref$[0], session = ref$[1], index = ref$[2];
    return {
      host: host,
      session: session,
      index: parseInt(index)
    };
  };
  out$.dmenu = dmenu = function(prompt, list, callback){
    var cp;
    cp = spawn('dmenu', dmenuCmd(prompt));
    cp.stdin.write(Buffer.from(list.join("\n")));
    cp.stdin.end();
    return cp.stdout.on('data', function(d){
      var choice;
      choice = d.toString().replace('\n', '');
      return callback(choice);
    });
  };
  out$.focused = focused = function(callback){
    return exec('xtitle', function(err, stdout, stderr){
      var id;
      id = windowNameToId(stdout);
      if (id.index == null) {
        return callback(null);
      } else {
        return callback(id);
      }
    });
  };
  out$.windows = windows = function(callback){
    return exec('wmctrl -l', function(err, stdout, stderr){
      var idList;
      idList = filter(function(id){
        return id.host != null && id.session != null && id.index != null;
      })(
      map(function(line){
        var words;
        words = line.split(' ');
        return windowNameToId(drop(4)(
        words).join(' '));
      })(
      lines(
      stdout)));
      return callback(idList);
    });
  };
  out$.sessions = sessions = function(host, callback){
    return exec(listCmd(host), function(err, stdout, stderr){
      if (err != null) {
        return console.log(err.message);
      } else {
        return callback(
        groupBy(function(it){
          return it.name;
        })(
        map(function(line){
          var columns, ref$, name, index;
          columns = line.split('\t');
          ref$ = columns[2].split(SC), name = ref$[0], index = ref$[1];
          return {
            active: columns[0][0] === '*',
            date: new Date(columns[1]),
            name: name,
            index: parseInt(index)
          };
        })(
        initial(
        tail(
        lines(
        stdout))))));
      }
    });
  };
  out$.nextIndex = nextIndex = function(sessions, session){
    var index;
    if (sessions[session] == null) {
      return 0;
    } else {
      return index = maximumBy(function(it){
        return it.index;
      })(
      sessions[session]).index + 1;
    }
  };
  out$.createNew = createNew = function(client, host, session, index){
    return spawn(TERMINAL, createCmd(TERMARGS, client, host, session, index));
  };
  out$.open = open = function(client, host, sessionName){
    return sessions(host, function(list){
      var session;
      session = list[sessionName];
      if (session == null) {
        console.log("Creating session " + sessionName);
        return createNew(client, host, sessionName, 0);
      } else {
        console.log("Open existing");
        return windows(function(idList){
          return each(function(window){
            return spawn(TERMINAL, openCmd(TERMARGS, client, host, window.name, window.index));
          })(
          filter(function(window){
            return !any(function(id){
              return id.host === host && id.session === window.name && id.index === window.index;
            })(
            idList);
          })(
          session));
        });
      }
    });
  };
}).call(this);
